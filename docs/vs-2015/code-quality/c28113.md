---
title: C28113 | Microsoft-Dokumentation
ms.custom: ''
ms.date: 2018-06-30
ms.prod: visual-studio-dev14
ms.reviewer: ''
ms.suite: ''
ms.technology:
- vs-devops-test
ms.tgt_pltfrm: ''
ms.topic: article
f1_keywords:
- C28113
helpviewer_keywords:
- C28113
ms.assetid: c3f4f143-6985-4274-a87a-59c21a82d67a
caps.latest.revision: 6
author: corob-msft
ms.author: gewarren
manager: ghogen
ms.openlocfilehash: 95d337f46826ba775f5b85228ab248a9e1879655
ms.sourcegitcommit: 55f7ce2d5d2e458e35c45787f1935b237ee5c9f8
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/22/2018
ms.locfileid: "47511449"
---
# <a name="c28113"></a>C28113
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Die neueste Version dieses Themas finden Sie unter [C28113](https://docs.microsoft.com/visualstudio/code-quality/c28113).  
  
Warnung C28113: Zugriff auf eine lokale Variable über eine Interlocked-Funktion  
  
 Der Treiber verwendet eine Interlocked-Ausführungsroutine wie z. B. [InterlockedDecrement](http://msdn.microsoft.com/library/windows/hardware/ff547871.aspx), um eine lokale Variable zuzugreifen.  
  
 Obwohl Treiber zulässig sind, um die Adresse einer lokalen Variablen an eine andere Funktion zu übergeben und anschließend eine Interlocked-Funktion für den Betrieb mit dieser Variable zu verwenden, ist es wichtig, sicherzustellen, dass der Stapel nicht unerwartet auf den Datenträger ausgelagert wird und dass die Variable über alle Threads hinweg, die sie verwenden könnten, die richtige Lebensdauer aufweist.  
  
## <a name="example"></a>Beispiel  
 In der Regel wird der Rückgabewert einer stützenden Interlocked-Ausführungsroutine in nachfolgenden Berechnungen anstelle der Eingabeargumente verwendet. Darüber hinaus schützen die Interlocked-Routinen nur das erste Argument (ganz links). Die Verwendung einer Interlocked-Routine auf folgende Weise schützt nicht den Wert der globalen Variable und dient häufig keinem Zweck.  
  
```  
InterlockedExchange(&local, global)  
```  
  
 Das folgende Format hat dieselbe Wirkung auf die Daten und greift sicher auf die globale Variable zu.  
  
```  
local = InterllockedExchange(&global, global)  
  
```



