---
title: C6014 | Microsoft Docs
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-code-analysis
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: C6014
helpviewer_keywords: C6014
ms.assetid: ef76ec88-74d2-4a3b-b6fe-4b0851ab3372
caps.latest.revision: "10"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: multiple
ms.openlocfilehash: a53d72035358f5a2a20adad09a3eb376242c8a5c
ms.sourcegitcommit: 32f1a690fc445f9586d53698fc82c7debd784eeb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/22/2017
---
# <a name="c6014"></a>C6014
Warnung C6014: Speicherverlust.  
  
 Diese Warnung gibt an, dass der angegebene Zeiger weist belegten Arbeitsspeicher oder andere Ressourcen, die nicht freigegeben wurde. Der Analyzer überprüft auf diese Bedingung, wenn die `_Analysis_mode_(_Analysis_local_leak_checks_)`-SAL-Anmerkung angegeben wird. Standardmäßig ist diese Anmerkung für den Windows-Kernelmoduscode (Treiber) angegeben. Weitere Informationen zu SAL-Anmerkungen finden Sie unter [mithilfe von SAL-Anmerkungen zum Reduzieren von C/C++-Codefehlern](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md).  
  
## <a name="example"></a>Beispiel  
 Der folgende Code generiert diese Warnung:  
  
```cpp  
// cl.exe /analyze /EHsc /nologo /W4  
#include <sal.h>  
#include <stdlib.h>  
#include <string.h>  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
  
#define ARRAYSIZE 10  
const int TEST_DATA [ARRAYSIZE] = {10,20,30,40,50,60,70,80,90,100};  
  
void f( )  
{  
    int *p = (int *)malloc(sizeof(int)*ARRAYSIZE);  
    if (p) {  
        memcpy(p, TEST_DATA, sizeof(int)*ARRAYSIZE);  
        // code ...  
    }  
}  
  
int main( )  
{  
    f();  
}  
  
```  
  
## <a name="example"></a>Beispiel  
 Der folgende Code korrigiert die Warnung durch den Arbeitsspeicher freigeben:  
  
```cpp  
// cl.exe /analyze /EHsc /nologo /W4  
#include <sal.h>  
#include <stdlib.h>  
#include <string.h>  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
  
#define ARRAYSIZE 10  
const int TEST_DATA [ARRAYSIZE] = {10,20,30,40,50,60,70,80,90,100};  
  
void f( )  
{  
    int *p = (int *)malloc(sizeof(int)*ARRAYSIZE);  
    if (p) {  
        memcpy(p, TEST_DATA, sizeof(int)*ARRAYSIZE);  
        // code ...  
        free(p);  
    }  
}  
  
int main( )  
{  
    f();  
}  
  
```  
  
 Diese Warnung wird für sowohl Speicher- und Ressourcenverluste gemeldet, wenn die Ressource häufig ist *Alias* an einen anderen Speicherort. Arbeitsspeicher wird als Alias verwendet, wenn ein Zeiger auf den Speicher die Funktion anhand der schützt ein `_Out_` parameteranmerkung, (globale Variable) oder Rückgabewert. Diese Warnung kann bei Funktionsende gemeldet werden, wenn das Argument mit Anmerkungen versehen ist, als dass freizugebenden erwartet wurde.  
  
 Beachten Sie, dass die Codeanalyse die eigentliche Implementierung eine speicherbelegung (mit einer Adresse, die arithmetische) wird nicht erkannt und erkennt nicht, dass der Arbeitsspeicher erhält (Obwohl viele Wrapper erkannt werden). In diesem Fall erkennt der Analyzer nicht, dass der Speicher belegt wurde, und gibt diese Warnung aus. Um den falsch positiv zu unterdrücken, verwenden Sie eine `#pragma` -Direktive auf die Zeile, die vor der öffnenden geschweiften Klammer `{` des Funktionstexts.  
  
 Um diese Arten von möglichen prüfen auf Speicherverluste vollständig zu vermeiden, verwenden Sie die Mechanismen, die von der C++-Standardvorlagenbibliothek Library (STL) bereitgestellt werden. Dazu gehören ["shared_ptr"](/cpp/standard-library/shared-ptr-class), [Unique_ptr](/cpp/standard-library/unique-ptr-class), und [Vektor](/cpp/standard-library/vector). Weitere Informationen finden Sie unter [intelligente Zeiger](/cpp/cpp/smart-pointers-modern-cpp) und [C++-Standardbibliothek](/cpp/standard-library/cpp-standard-library-reference).  
  
```cpp  
// cl.exe /analyze /EHsc /nologo /W4  
#include <sal.h>  
#include <memory>  
  
using namespace std;  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
  
const int ARRAYSIZE = 10;  
const int TEST_DATA [ARRAYSIZE] = {10,20,30,40,50,60,70,80,90,100};  
  
void f( )  
{  
  
    unique_ptr<int[]> p(new int[ARRAYSIZE]);  
    std::copy(begin(TEST_DATA), end(TEST_DATA), p.get());  
  
    // code ...  
  
    // No need for free/delete; unique_ptr   
    // cleans up when out of scope.  
}  
  
int main( )  
{  
    f();  
}  
  
```  
  
## <a name="see-also"></a>Siehe auch  
 [C6211](../code-quality/c6211.md)