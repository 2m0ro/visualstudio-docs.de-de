---
title: C26426
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C26426
helpviewer_keywords:
- C26426
ms.assetid: 6fb5f6d2-b097-47f8-8b49-f2fd4e9bef0e
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: c2a06aabf5a06133e77c5087bd02a41688dc7afe
ms.sourcegitcommit: 240c8b34e80952d00e90c52dcb1a077b9aff47f6
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/23/2018
ms.locfileid: "49892739"
---
# <a name="c26426-noglobalinitcalls"></a>C26426 NO_GLOBAL_INIT_CALLS
"Der globale Initialisierer Ruft eine nicht-Constexpr-Funktion."

**C++ zentrale Richtlinien**: I.22: komplexe Initialisierung von globalen Objekten vermeiden

Die Reihenfolge der Ausführung der Initialisierer für globale Objekte möglicherweise inkonsistent oder nicht definiert. Dies kann zu Problemen führen, die schwer zu reproduzieren und untersuchen. Um solche Probleme zu vermeiden, globalen Initialisierer sollten nicht externen Code, der zur Laufzeit ausgeführt wird abhängen und können sich möglicherweise je nach Daten, die noch nicht initialisiert ist. Mit dieser Regel Bitflags, die Fälle, in dem globale Objekte Funktionsaufrufe verwenden, um die ursprünglichen Werte zu erhalten.

## <a name="remarks"></a>Hinweise
- Die Regel ignoriert Aufrufe von Constexpr-Funktionen oder die systeminterne Funktionen auf der Annahme, die diese entweder am berechnet werden Kompilierzeit oder zielanwendungen vorhersagbare zur Laufzeit.
  - Aufrufe von Inlinefunktionen sind immer noch gekennzeichnet werden, da es sich bei der voraussetzungsprüfung nicht versucht, um ihre Implementierung zu analysieren.
  - Mit dieser Regel kann ziemlich entsprechende abweichungen auf, in vielen gängigen Szenarien, die eine Variablen eines benutzerdefinierten Typs (oder den Standardcontainer) ist, in dem Global initialisiert sein: Dies ist häufig aufgrund von Aufrufen an die Konstruktoren und Destruktoren. Dies ist immer noch gültige Warnung, da er stellen zeigt, in denen es möglicherweise zu einem unvorhersehbaren Verhalten vorhanden oder zukünftige Änderungen in externen Code können Instabilität führen.
  - Statische Klassenmember werden global betrachtet die Initialisierer überprüft werden.
    ## <a name="example"></a>Beispiel
    externe versionsüberprüfung / / api.cpp Int ppi_version = API_DEFAULT_VERSION; Wird davon ausgegangen Sie, dass es zur Laufzeit wird daher nicht Konstanten ändern kann.
    Int get_api_version() "noexcept" {return ppi_version};

Client.cpp Int get_api_version() Noexcept; "bool" Is_legacy_mode get_api_version() = < = API_LEGACY_VERSION; C26426, auch die veralteten Wert

## <a name="example"></a>Beispiel
externe Prüfung – Zuverlässigkeit

```cpp
// api.cpp
int& api_version() noexcept {
    static auto value = API_DEFAULT_VERSION;
    return value;
}
int get_api_version() noexcept {
    return api_version();
}

// client.cpp
int get_api_version() noexcept;
bool is_legacy_mode() noexcept {
    return get_api_version() <= API_LEGACY_VERSION;
}
```
