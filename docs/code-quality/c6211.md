---
title: C6211 | Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C6211
helpviewer_keywords:
- C6211
ms.assetid: 9b68243b-534c-4a05-b789-bb155dfcba1e
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 290e1a81f0ff8c560c64fd75ceb51a64f4bb652e
ms.sourcegitcommit: 6a9d5bd75e50947659fd6c837111a6a547884e2a
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/16/2018
---
# <a name="c6211"></a>C6211
Warnung C6211: Speicherverlust \<Zeiger > aufgrund einer Ausnahme. Verwenden Sie einen lokalen Catch-Block, um den Arbeitsspeicher zu bereinigen.  
  
 Diese Warnung gibt an, dass der reservierter Speicher nicht freigegeben wird ist, wenn eine Ausnahme ausgelöst wird. Die Anweisung am Ende des Pfads konnte eine Ausnahme ausgelöst. Der Analyzer überprüft auf diese Bedingung, wenn die `_Analysis_mode_(_Analysis_local_leak_checks_)`-SAL-Anmerkung angegeben wird. Standardmäßig ist diese Anmerkung für den Windows-Kernelmoduscode (Treiber) angegeben. Weitere Informationen zu SAL-Anmerkungen finden Sie unter [mithilfe von SAL-Anmerkungen zum Reduzieren von C/C++-Codefehlern](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md).  
  
## <a name="example"></a>Beispiel  
 Der folgende Code generiert diese Warnung, weil eine Ausnahme während der zweiten Zuordnung und dadurch Speicherverluste der ersten Zuweisung ausgelöst werden konnte oder eine Ausnahme kann an einer beliebigen Stelle im Code, der durch dargestellt wird ausgelöst werden die "`code ...`" Kommentar und dadurch Verbreiten Sie, die beide Zuordnungen.  
  
```cpp  
// cl.exe /analyze /c /EHsc /nologo /W4   
#include <sal.h>  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
void f( )  
{  
    char *p1 = new char[10];  
    char *p2 = new char[10];  
  
    // code ...  
  
    delete[] p2;  
    delete[] p1;  
}  
  
```  
  
 Die gleichen Zuordnungsmethoden, und dieses Problem zu beheben, fügen Sie einen Ausnahmehandler hinzu:  
  
```cpp  
// cl.exe /analyze /c /EHsc /nologo /W4  
#include <sal.h>  
#include <new>  
#include <iostream>  
using namespace std;  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
  
void f()  
{  
    char *p1 = nullptr;   
    char *p2 = nullptr;  
  
    try  
    {  
        p1 = new char[10];  
        p2 = new char[10];  
  
        // code ...  
  
        delete [] p2;  
        delete [] p1;  
    }  
    catch (const bad_alloc& ba)  
    {  
        cout << ba.what() << endl;  
        delete [] p2;  
        delete [] p1;  
    }  
    // code ...  
}  
  
```  
  
 Um diese Arten von möglichen prüfen auf Speicherverluste vollständig zu vermeiden, verwenden Sie die Mechanismen, die von der C++-Standardvorlagenbibliothek Library (STL) bereitgestellt werden. Dazu gehören ["shared_ptr"](/cpp/standard-library/shared-ptr-class), [Unique_ptr](/cpp/standard-library/unique-ptr-class), und [Vektor](/cpp/standard-library/vector). Weitere Informationen finden Sie unter [intelligente Zeiger](/cpp/cpp/smart-pointers-modern-cpp) und [C++-Standardbibliothek](/cpp/standard-library/cpp-standard-library-reference).  
  
```cpp  
// cl.exe /analyze /c /EHsc /nologo /W4  
#include <sal.h>  
#include <vector>  
#include <memory>  
  
using namespace std;  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
  
void f( )  
{  
    // use 10-element vectors in place of char[10]  
    vector<char> v1;  
    vector<char> v2;  
  
    for (int i=0; i<10; ++i) {  
        v1.push_back('a');  
        v2.push_back('b');  
    }  
    // code ...  
  
    // use unique_ptr if you still want char[10]  
    unique_ptr<char[]> a1(new char[10]);  
    unique_ptr<char[]> a2(new char[10]);  
  
    // code ...  
  
    // No need for delete; vector and unique_ptr   
    // clean up when out of scope.  
}  
  
```  
  
## <a name="see-also"></a>Siehe auch  
 [C++-Ausnahmebehandlung](/cpp/cpp/cpp-exception-handling)