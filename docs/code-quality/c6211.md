---
title: "C6211 | Microsoft Docs"
ms.custom: ""
ms.date: "12/02/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-devops-test"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "C6211"
helpviewer_keywords: 
  - "C6211"
ms.assetid: 9b68243b-534c-4a05-b789-bb155dfcba1e
caps.latest.revision: 24
caps.handback.revision: 24
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
---
# C6211
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

Warnung C6211: Speicherverlust \<Zeiger\> aufgrund einer Ausnahme.  Verwenden Sie einen lokalen Catch\-Block, um den Arbeitsspeicher zu bereinigen.  
  
 Diese Warnung gibt an, dass der belegte Arbeitsspeicher bei Auslösung einer Ausnahme nicht freigegeben wird.  Die Anweisung am Ende des Pfads löst möglicherweise eine Ausnahme auslösen.  Der Analyzer überprüft auf diese Bedingung, wenn die `_Analysis_mode_(_Analysis_local_leak_checks_)`\-SAL\-Anmerkung angegeben wird.  Standardmäßig ist diese Anmerkung für den Windows\-Kernelmoduscode \(Treiber\) angegeben.  Weitere Informationen zu SAL\-Anmerkungen finden Sie unter [Verwenden von SAL\-Anmerkungen zum Reduzieren von C\/C\+\+\-Codefehlern](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md).  
  
## Beispiel  
 Der folgende Code generiert diese Warnung, weil eine Ausnahme während der zweiten Zuordnung ausgelöst und die erste Zuordnung und freigegeben werden kann oder eine Ausnahme im Code die ausgelöst werden, der durch den Kommentar "`code ...`" dargestellt ist und beide Zuordnungen und freigegeben werden kann.  
  
```cpp  
// cl.exe /analyze /c /EHsc /nologo /W4   
#include <sal.h>  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
void f( )  
{  
    char *p1 = new char[10];  
    char *p2 = new char[10];  
  
    // code ...  
  
    delete[] p2;  
    delete[] p1;  
}  
  
```  
  
 Wenn Sie dieselben Zuordnungsmethoden verwenden und dieses Problem zu beheben, fügen Sie einen Ausnahmehandler hinzu:  
  
```cpp  
// cl.exe /analyze /c /EHsc /nologo /W4  
#include <sal.h>  
#include <new>  
#include <iostream>  
using namespace std;  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
  
void f()  
{  
    char *p1 = nullptr;   
    char *p2 = nullptr;  
  
    try  
    {  
        p1 = new char[10];  
        p2 = new char[10];  
  
        // code ...  
  
        delete [] p2;  
        delete [] p1;  
    }  
    catch (const bad_alloc& ba)  
    {  
        cout << ba.what() << endl;  
        delete [] p2;  
        delete [] p1;  
    }  
    // code ...  
}  
  
```  
  
 Um diese Arten möglicher Verlusten vollkommen zu vermeiden, verwenden Sie die Mechanismen die von der C\+\+\-Standardvorlagenbibliothek \(STL\) bereitgestellt werden.  Dazu gehören [shared\_ptr](/visual-cpp/standard-library/shared-ptr-class), [unique\_ptr](/visual-cpp/standard-library/unique-ptr-class) und [vector](../Topic/%3Cvector%3E.md).  Weitere Informationen finden Sie unter [Intelligente Zeiger](/visual-cpp/cpp/smart-pointers-modern-cpp) und [C\+\+\-Standardbibliothek](/visual-cpp/standard-library/cpp-standard-library-reference).  
  
```cpp  
// cl.exe /analyze /c /EHsc /nologo /W4  
#include <sal.h>  
#include <vector>  
#include <memory>  
  
using namespace std;  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
  
void f( )  
{  
    // use 10-element vectors in place of char[10]  
    vector<char> v1;  
    vector<char> v2;  
  
    for (int i=0; i<10; ++i) {  
        v1.push_back('a');  
        v2.push_back('b');  
    }  
    // code ...  
  
    // use unique_ptr if you still want char[10]  
    unique_ptr<char[]> a1(new char[10]);  
    unique_ptr<char[]> a2(new char[10]);  
  
    // code ...  
  
    // No need for delete; vector and unique_ptr   
    // clean up when out of scope.  
}  
  
```  
  
## Siehe auch  
 [C\+\+\-Ausnahmebehandlung](/visual-cpp/cpp/cpp-exception-handling)